# general

Wayland works on "objects" that enclose methods. All requests are method invocations on them, and include an object ID. Each object implements an interface and the requests include an opcode that identifies method in the interface to invoke.

Communication compositor↔client happens through UNIX sockets called `wayland-0` *(can be overridden)*.

# bestiary

* `object`: an instance of a `interface`. Can be global *(i.e. ideantical for all clients)*, or local to every client. "Created" with `wl_registry_bind`, destroyed with interface's `*_destroy` method from the generated code.
* `destructor`: the opposite of `wl_registry_bind`. Can be overridden by manually declaring in XML a destructor method. When object is global, it's `destroy` may just destroy the client-side part.
* `request`: a message sent from a client to server.
* `event`: a message sent from server to a client.
* `globals`: global resources, stuff like `wl_outputs` *(which displays are connected; also this specific global supplies `wl_registry`)*.
* `wl_display`: something. Client gets it upon making Wayland connection.
* `wl_registry`: a list of available `globals`, "things you can create from then on", apparently list of interfaces. Created out of `wl_display`.
* `wl_surface`: a rectangle that clients draws in. Essentially a window. Has events for whether it's visible.
* `wl_interface`: a struct with a description of protocol object. A list of fields: {protocol name, protocol version, num requests, requests `:: [wl_message]`, num events, events `:: [wl_message]`}
* `wl_message`: a description of a function arguments/return value in Wayland byte-code.

# misc

An extension is basically bunch of callbacks between a client and compositor. Details depends on extension.

Clients are usually using libwayland which to supply callbacks for certain events.

# code generation

Happens through `wayland-scanner` binary. Usage example: `wayland-scanner client-header xdg-shell.xml out.c`. The help output is clear on supported options *(though not on their meaning)*.

xml construction: protocol(mandatory) → interface(mandatory) → events/requests (optional).

## minimum code

adding a request `foobar` with no other parameters results in `#define INTERFACE_NAME_FOOBAR 1`, `#define INTERFACE_NAME_FOOBAR_SINCE_VERSION 1`, and a method implementation
    ```
    static inline
    void interface_name_foobar(struct interface_name *interface_name) {
        wl_proxy_marshal((struct wl_proxy *) interface_name, INTERFACE_NAME_FOOBAR);
    }
    ```

* adding an event `foobar` with no other parameters results in `#define INTERFACE_NAME_FOOBAR_SINCE_VERSION 1`, and
    ```
    struct interface_name_listener {
        void (*foobar)(void *data, struct interface_name *interface_name);
    };

    static inline
    int interface_name_add_listener(struct interface_name *interface_name,
                                    const struct interface_name_listener *listener, void *data) {
        return wl_proxy_add_listener((struct wl_proxy *) interface_name,
                                    (void (**)(void)) listener, data);
    }
    ```

# proxy

Represents an object on client side. Docs for `wl_proxy` say it shouldn't be used directly, instead clients should use higher-level interface generated by `wayland-scanner`. `wl_proxy` converts through `wl_proxy_marshal` requests into wire format, and calls handlers set with `wl_proxy_add_listener` when they're coming.

# internals

Basic communication is implemented at `libwayland-server.c`/`libwayland-client.c`.

# references

http://www.jlekstrand.net/jason/projects/wayland/language-bindings-guide/ nice overview of how the xml sticks together with the final code.
http://sircmpwn.github.io/2017/06/10/Introduction-to-Wayland.html wayland from a POV of client.
